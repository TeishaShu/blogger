{"meta":{"title":"亭夏 Teisha - 邁向前端","subtitle":"","description":"","author":"Teisha HSU","url":"https://teishashu.github.io","root":"/blogger/"},"pages":[{"title":"","date":"2020-06-28T15:45:04.000Z","updated":"2020-06-29T02:47:05.434Z","comments":true,"path":"categories/index.html","permalink":"https://teishashu.github.io/categories/index.html","excerpt":"","text":""},{"title":"關於","date":"2020-06-28T15:45:04.000Z","updated":"2020-07-01T07:40:34.287Z","comments":true,"path":"about/index.html","permalink":"https://teishashu.github.io/about/index.html","excerpt":"","text":"高中、大學關於廣告、商業設計的7年美學培養，畢業後從事網頁設計從此開始接觸 HTML、CSS、jQuery、Bootstrap 過程中發現如果要把網頁做得更好，除了多看網站來設計外，也需要學會寫 JavaScript 這樣才可以做得更彈性變化更多，不知不覺就往前端的方向走過去了! 開始寫文章是因為一直以來讀書都很喜歡寫筆記，但是紙本很容易一陣子就不見了或者不容易查詢，後來慢慢電子化後發現寫部落格蠻不錯的，可以快速查詢又可以練習表達思緒。"},{"title":"更多資訊","date":"2020-06-29T02:14:02.000Z","updated":"2020-08-03T13:43:14.752Z","comments":true,"path":"more/index.html","permalink":"https://teishashu.github.io/more/index.html","excerpt":"","text":"友情連結 Albert Coding after exercise 練習專案( 前端 )比較專注於 JavaScript 和 Vue 的使用 MIAO 來呷飽貓食堂 (使用 Vue cli ) 空氣品質指標 (使用 Vue ) 純表單 (使用 JavaScript ) ( 網頁設計 )設計到切版 RWD 響應式網頁製作 html5、css3、bootstrap 台灣國際物業管理 佑崧企業有限公司 上德特殊印刷"},{"title":"","date":"2020-06-29T02:14:02.000Z","updated":"2020-06-29T02:46:52.135Z","comments":true,"path":"tags/index.html","permalink":"https://teishashu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Vue CLI 3.0 環境變數 env","slug":"vue-env","date":"2020-08-20T16:00:00.000Z","updated":"2020-08-22T08:00:22.998Z","comments":true,"path":"2020/08/21/vue-env/","link":"","permalink":"https://teishashu.github.io/2020/08/21/vue-env/","excerpt":"官網開發環境跟正式環境的主機不同.導致網站路徑不同，開發通常使用內部測試的 API 、測試的資料庫，正式才會用正式的 API，避免使用正式主機做開發。","text":"官網開發環境跟正式環境的主機不同.導致網站路徑不同，開發通常使用內部測試的 API 、測試的資料庫，正式才會用正式的 API，避免使用正式主機做開發。 檔名命名方式1234.env 所有環境中載入檔案內所有變數.env.local 同上.但會被git忽略.env.[mode] 指定模式中載入.env.[mode].local 同上.但會被git忽略 文件撰寫方法2種寫法.下面的前面一定要 VUE_APP_ 開頭沒有加 src 裡面的檔案讀不到變數 12FOO&#x3D;barVUE_APP_SECRET&#x3D;secret 讀出來12&#x2F;&#x2F; process.env.名稱process.env.VUE_APP_SECRET *如果出現 undefined設定好 env 後要重新啟動這服務 npm run serve 步驟 建立新文件 (檔名叫 .env ) 寫檔案內容 (VUE_APP_ 開頭) .env.development 檔案預設的這個比 .env 權重高.因此不用另外在 package.json 的 server 設定development 模式用於 vue-cli-service serve (預設環境)production 模式用於 vue-cli-service build 和 vue-cli-service test:e2e (預設環境) 特定檔案檔案名稱 .env.CY在 package.json 的 server 可以設定切換特定環境加上「–mode 名稱」 123&quot;script&quot;: &#123; &quot;serve&quot;: &quot;vue-cli-service serve --mode CY&quot;,&#125;, 存檔後再重新啟動 npm run serve","categories":[{"name":"Vue","slug":"Vue","permalink":"https://teishashu.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://teishashu.github.io/tags/Vue/"}]},{"title":"VueX - 3. Getter、Modules 簡化與模組化","slug":"vuex-3簡化模組","date":"2020-08-06T16:00:00.000Z","updated":"2020-08-21T14:29:02.070Z","comments":true,"path":"2020/08/07/vuex-3簡化模組/","link":"","permalink":"https://teishashu.github.io/2020/08/07/vuex-3%E7%B0%A1%E5%8C%96%E6%A8%A1%E7%B5%84/","excerpt":"Getter目的: 資料呈現前調整(類似 computed )。資料出現在網頁上之前做一些過濾、加減","text":"Getter目的: 資料呈現前調整(類似 computed )。資料出現在網頁上之前做一些過濾、加減 調整資料(類似 computed )這塊官網也得很清楚 整理 state 資料把需要從 state 叫出來的資料在 computed 塞選過濾的方式可以在 getter 中處理好。1234567891011121314151617181920const store &#x3D; new Vuex.Store(&#123; state: &#123; todos: [ &#123; id: 1, text: &#39;...&#39;, done: true &#125;, &#123; id: 2, text: &#39;...&#39;, done: false &#125; ] &#125;, getters: &#123; doneTodos(state, getter) &#123; return state.todos.filter(todo &#x3D;&gt; todo.done) &#125; &#125;&#125;)&#x2F;&#x2F;在 component 中使用下面 code 可抓到資料computed: &#123; doneTodosFilter () &#123; return this.$store.getters.doneTodos; &#125;&#125; 如果是在其他模組裡面的要用 mapGetters 回傳值官網範例筆記一下注意: 每次都會去進行調用，不會缓存结果。(有帶參數的範例) 1234567getters: &#123; getTodoById: (state) &#x3D;&gt; (id) &#x3D;&gt; &#123; return state.todos.find(todo &#x3D;&gt; todo.id &#x3D;&#x3D;&#x3D; id) &#125;&#125;store.getters.getTodoById(2) &#x2F;&#x2F; -&gt; &#123; id: 2, text: &#39;...&#39;, done: false &#125; mapGetters 針對 computed 簡化 或取 getters 資料相關行為從 store 讀出來，有 mapGetters、mapActions 這 2 個簡化程式方式差不多。mapGetters 針對 computed 簡化；mapActions 針對 methods 簡化(這個寫在上一篇) 使用狀況:computed 程式感覺重複太多 or 其他頁也會一值使用，因此改成在 vuex 中的 getter 寫法。 原本 component 中程式的樣子 12345678computed: &#123; isLoading()&#123; return this.$store.state.isLoading; &#125;, cart()&#123; return this.$store.state.cart; &#125;&#125;, 修改 step 1 :設定 getters把 computed 中使用到 vuex 的部分移動到 getter 中 (也是要 return 回傳資料) 12345678getters:&#123; isLoading(state)&#123; return state.isLoading; &#125;, cart(state)&#123; return state.cart; &#125;&#125; 修改 step 2 :引入並使用 mapGetters注意 { mapGetters } 是物件形式.不要忘了加! 123456789&lt;script&gt;import &#123; mapGetters &#125; from &#39;vuex&#39;; &#x2F;&#x2F; step 2-1 引入 mapGettersexport default &#123; computed: &#123; ...mapGetters([&#39;isLoading&#39;, &#39;cart&#39;]) &#x2F;&#x2F; step 2-2 修改成 mapGetters ...mapGetters(&#39;productsModules&#39;, [&#39;isLoading&#39;, &#39;cart&#39;]) &#x2F;&#x2F; 加入群組的名稱 &#125;,&#125;&lt;&#x2F;script&gt; ModulesVueX 檔案模組化分成幾個檔案.引入加上來的地方。 新增模板並把相關資料移動進去index.js 這檔案是先建立一個 vuex 123import axios from &#39;axios&#39;; &#x2F;&#x2F; 如果需要axios在增加export default:&#123;&#125; 在把 index.js 中 state、mutations、actions、getters 一起複製過去增加刪減 這邊當時卡了一下.因為一開始複製整個 index.js 過去改vuex重複2次創建.所以產生錯誤查到下面文章解決[vuex] getters should be function but 在 store/index.js 中引入A. import 進來模板 12345678import Vue from &#39;vue&#39;import Vuex from &#39;vuex&#39;import axios from &#39;axios&#39;;import productsModules from &quot;.&#x2F;products&quot;; &#x2F;&#x2F; 這邊加入這段引用進來(注意命名的名稱會時常使用)Vue.use(Vuex) &#x2F;&#x2F;這邊 vuex 啟用export default new Vuex.Store(&#123;.....&#125;) B. 增加 modules 12345678910export default new Vuex.Store(&#123; strict: true, state: &#123;...&#125;, mutations: &#123;...&#125;, actions: &#123;...&#125;, getters:&#123;...&#125;, modules: &#123; &#x2F;&#x2F;其他模板引入 productsModules, &#125;&#125;) 改到這邊檔案是沒問題的 一般情況的區域、全域狀況 state 區域變數 actions、mutations、getters 全域變數(全域擔心的是跟其他檔案的名稱一樣造成衝突不好管理) 1. 全部改成區域變數 namespaced設定 namespaced: true, 123export default &#123;namespaced: true,state: &#123;..&#125;, 2. 模組化後調用其他模組的方法沒用會報錯[vuex] unknown action type:注意: 一開始在 store/index.js 中引入的其他 modules 名稱.是使用引入名稱.不是檔案名稱。 12&#x2F;&#x2F; 名稱是 productModules 不是 productsimport productModules from &quot;.&#x2F;products&quot;; 參考vuex 模块化之后如何调用其他模块的方法和属性modules 1 modules 2 分成在 component、store 兩個部分的寫法。 2-1. component 中A. 更改 computed1234567products() &#123; &#x2F;&#x2F;原本-根目錄的 return this.$store.state.products; &#x2F;&#x2F;更改 return this.$store.state.productModules.products;&#125;, B. 使用 getter、state使用 mapGetters、mapActions 12345678910111213import &#123;mapStates, mapGetters&#125; from &#39;vuex&#39;;export default &#123; computed:&#123; ...mapStates([&#39;todos&#39;]), ...mapGetters([&#39;itemNotDone&#39;,&#39;itemWithID&#39;]), ...mapGetters(&#39;productModules&#39;,[&#39;itemNotDone&#39;,&#39;itemWithID&#39;]), &#x2F;&#x2F; 使用到其他 modules 時.要加檔案引入名稱 &#125;, methods:&#123; test()&#123; this.itemWithID(&#39;123&#39;); &#125;, &#125;,&#125;; C. methods 中使用路徑需要更改 (文件引入index.js的名稱/actions 下的方法) 1this.$store.dispatch(&#39;productModules&#x2F;selectCategory&#39;, &#123;style,isPageClick&#125;); 需要用 getter、state 的要用上面的 computed (跨 modules 要用 mapGetters) 2-2. store 中A. 加入 { root: true } 注意:store 的檔案中需要，component 的檔案不需要使用到其他模組的 mutation、action，需要在 dispatch、commit 的第三個參數帶入 { root: true }，表示這個 mutation、action 不是目前模組的。 123context.commit(&#39;LOADING&#39;, true); &#x2F;&#x2F; 自己檔案的 LOADINGcontext.commit(&#39;LOADING&#39;, true, &#123;root: true&#125;); &#x2F;&#x2F; 根目錄的 LOADINGcontext.commit(&#39;productModules&#x2F;LOADING&#39;, true, &#123;root: true&#125;); &#x2F;&#x2F; productModules 檔案的 LOADING B. 其他模組的 state、getteraction 中需要使用 context 屬性modules 跨模組才有 rootState、rootGetters rootState // 等同於 store.state，只存在於模版中 rootGetters // 等同於 store.getters，只存在於模版中 可以使用 context 或分開寫 123456789101112131415&#x2F;&#x2F; 使用 contextaddCartProductIn(context) &#123; context.commit(&#39;productModules&#x2F;LOADING&#39;, true, &#123;root: true&#125;); &#x2F;&#x2F; 使用其他模組的 mutation context.dispatch(&#39;productModules&#x2F;cartBtnApi&#39;, &#123;&#125;, &#123;root: true&#125;); &#x2F;&#x2F; 使用其他模組的 action context.rootState.productModules.selectNum; &#x2F;&#x2F; 獲取其他模組的 state&#125;,&#x2F;&#x2F; 分開寫 (要用物件形式)addCartProductIn(&#123;commit, rootState, dispatch&#125;) &#123; commit(&#39;productModules&#x2F;LOADING&#39;, true, &#123;root: true&#125;); dispatch(&#39;productModules&#x2F;cartBtnApi&#39;, &#123;&#125;, &#123;root: true&#125;); rootState.productModules.selectNum; rootState[&#39;productModules&#x2F;selectNum&#39;]; &#x2F;&#x2F; 也可以這個&#125;, 官網還有很多其他 Modules 的應用","categories":[{"name":"Vue","slug":"Vue","permalink":"https://teishashu.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://teishashu.github.io/tags/Vue/"},{"name":"VueX","slug":"VueX","permalink":"https://teishashu.github.io/tags/VueX/"}]},{"title":"VueX - 2. State、Mutations、Actions 狀態","slug":"vuex-2屬性","date":"2020-08-05T16:00:00.000Z","updated":"2020-08-21T09:52:14.339Z","comments":true,"path":"2020/08/06/vuex-2屬性/","link":"","permalink":"https://teishashu.github.io/2020/08/06/vuex-2%E5%B1%AC%E6%80%A7/","excerpt":"State目的: 管理資料狀態.資料儲存 (類似 data )。 將 component 頁面中需要放到 VueX 管理的 data 資料放到 state 裡統一控制，修改的 data 換成使用 computed 回傳值。","text":"State目的: 管理資料狀態.資料儲存 (類似 data )。 將 component 頁面中需要放到 VueX 管理的 data 資料放到 state 裡統一控制，修改的 data 換成使用 computed 回傳值。 12345678910111213&#x2F;&#x2F; 資料夾 src&#x2F;store&#x2F;index.js 中export default new Vuex.Store(&#123; state: &#123; isLoading:false, &#125;,&#125;)&#x2F;&#x2F; component 頁面(store前面記得加$)computed:&#123; isLoading()&#123; return this.$store.state.isLoading; &#125;&#125; Mutations目的處理資料 state 的狀態(改變資料內容)。 改動 state，(這邊改 devtools 也會變) 執行同步行為 使用常數(全都大寫名稱來區分.也可以不這樣用) 12345678910mutations: &#123; &#x2F;&#x2F; LOADING 跟 actions 的 updateLoading 提交的名稱有關 &#x2F;&#x2F; 第一個填 state，第二個要傳的資料 (payload).太多資料用物件 LOADING (state, payload) &#123; state.isLoading &#x3D; payload; &#125;, INCREMENT (state, payload) &#123; state.count +&#x3D; payload.amount &#125;&#125;, 使用 commit 觸發1234567891011121314151617181920&#x2F;&#x2F; component 的 methods 中使用store.commit(&#39;LOADING&#39;, true);&#x2F;&#x2F; 物件方式.第二個可以放比較多參數(但如果沒有全放只改要改的值.其他參數會不見出錯)store.commit(&#39;INCREMENT&#39;, &#123; amount: 10&#125;);store.commit(&#123; type: &#39;INCREMENT&#39;, amount: 10&#125;)&#x2F;&#x2F; actions 中使用actions: &#123; &#x2F;&#x2F; LOADING 是 updateLoading 提交的「 Mutation 名稱」 updateLoading(context,changeStatus)&#123; &#x2F;&#x2F; 改變資料這樣寫 context.commit(&#39;LOADING&#39;,changeStatus); &#125;&#125;, 網頁開發者工具中只要觸發在 Filter mutations 搜尋的下面會看到觸發的時點和名稱畫面右邊會顯示 state、mutations 的狀況(state、mutations 的資料要同步才正常) Actions目的 操作一些動作(類似 methods )、取得遠端資料(不會改變資料狀態)處理 API (非同步、取得遠端資 ajax )、setTimeout (資料處理是在 mutations )。 可以串接很多功能( mutations 和其他的 actions)，也可以拿getters、state的資料注意資料的順序方向.不要逆向。 context 屬性 使用範例.第一位是 context 屬性 12345actions: &#123; updateLoading(context,changeStatus)&#123; context.commit(&#39;LOADING&#39;,changeStatus); &#125;&#125;, context 有下面這些屬性 (** 注意是 context 中有這些) 12345678910&#123; state, &#x2F;&#x2F; 等同於 &#96;store.state&#96;，若在模版中則為局部狀態 commit, &#x2F;&#x2F; 等同於 &#96;store.commit&#96; dispatch, &#x2F;&#x2F; 等同於 &#96;store.dispatch&#96; getters, &#x2F;&#x2F; 等同於 &#96;store.getters&#96; &#x2F;&#x2F; 下面2個使用 modules 才有 rootState, &#x2F;&#x2F; 等同於 &#96;store.state&#96;，只存在於模版中 rootGetters &#x2F;&#x2F; 等同於 &#96;store.getters&#96;，只存在於模版中&#125; 使用 dispatch 呼叫 在 component 的 methods 中使用 1this.$store.dispatch(&#39;名稱&#39;,true); 在 actions 中使用其他的 function使用 context 下的 dispatch 12345context.dispatch(&#39;名稱&#39;)&#x2F;&#x2F;例子this.aaa(); &#x2F;&#x2F; 原本呼叫 aaa function 的方式context.dispatch(&#39;aaa&#39;); &#x2F;&#x2F; 變成這樣呼叫 很多參數需要傳的狀況下「全部用物件」方式 12345678this.selectCategory(categoryStyle, false); &#x2F;&#x2F; 原本&#x2F;&#x2F; 修改context.dispatch(&#123; type: &#39;selectCategory&#39;, style: categoryStyle, isPageClick: false&#125;); action 中.太多參數要用物件傳入 1selectCategory (context, &#123;style, isPageClick&#125;) &#123;...&#125; mapActions 針對 methods 簡化 原本 component 中的樣子 12345678910methods: &#123; &#x2F;&#x2F; 這可以簡化 addCartProductIn() &#123; this.$store.dispatch(&#39;addCartProductIn&#39;); &#125;, &#x2F;&#x2F; 這無法簡化.因為有參數需要傳入 changeNum(num) &#123; this.$store.dispatch(&#39;changeNum&#39;, num) &#125;,&#125;, 修改 step 1component 中引入 mapActions 1234&lt;script&gt;import &#123; mapGetters, mapActions &#125; from &#39;vuex&#39;; &#x2F;&#x2F; 加入這段(沒 mapGetters 就刪除 mapGetters)export default &#123;...&#125;&lt;&#x2F;script&gt; 修改 step 2改變 component 中的設定注意:需要帶參數進去的無法縮減 123456methods: &#123; changeNum(num) &#123; this.$store.dispatch(&#39;changeNum&#39;, num); &#x2F;&#x2F; 無法縮減 &#125;, ...mapActions([&#39;addCartProductIn&#39;]), &#x2F;&#x2F; 改這邊&#125;, tipVueX 中太多參數要傳遞.都是用物件方式(解構)因為是解構所以參數可以直接用 1234567891011121314151617181920212223242526&#x2F;&#x2F; component 頁面addtoCart(id, qty &#x3D; 1) &#123; &#x2F;&#x2F; 「&#x3D; 1」預設值的意思 &#x2F;&#x2F; 原本參數太多 &#x2F;&#x2F; this.$store.dispatch(&#39;addtoCart&#39;,id, qty); &#x2F;&#x2F; 用物件包起來 this.$store.dispatch(&#39;addtoCart&#39;,&#123;id, qty&#125;);&#125;,&#x2F;&#x2F; vuex 裡面addtoCart(context, &#123;id, qty&#125;) &#123; &#x2F;&#x2F;注意!不要寫上預設值。解構-&gt;直接用參數即可 const vm &#x3D; this; const url &#x3D; &#96;$&#123;process.env.APIPATH&#125;&#x2F;api&#x2F;$&#123;process.env.CUSTOMPATH&#125;&#x2F;cart&#96;; const item &#x3D; &#123; product_id: id, qty, &#125;; context.commit(&#39;LOADING&#39;,true) axios.post(url, &#123; data: item &#125;).then((response) &#x3D;&gt; &#123; context.commit(&#39;LOADING&#39;,false) context.dispatch(&#39;getCart&#39;); console.log(&#39;加入購物車:&#39;, response); &#125;);&#125;,","categories":[{"name":"Vue","slug":"Vue","permalink":"https://teishashu.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://teishashu.github.io/tags/Vue/"},{"name":"VueX","slug":"VueX","permalink":"https://teishashu.github.io/tags/VueX/"}]},{"title":"VueX - 1. 前言","slug":"vuex-1前言","date":"2020-08-04T16:00:00.000Z","updated":"2020-08-14T07:02:14.132Z","comments":true,"path":"2020/08/05/vuex-1前言/","link":"","permalink":"https://teishashu.github.io/2020/08/05/vuex-1%E5%89%8D%E8%A8%80/","excerpt":"目的 針對大型專案使用 管理跨層(跨 component)的資料狀態","text":"目的 針對大型專案使用 管理跨層(跨 component)的資料狀態 父子層可以用 emit、props 來傳遞資料。同層級的用 $eventbus 來傳遞資料(適合簡單的情境.資料量大時容易亂掉)。全域變數資料無法做雙向綁定。 因此，大型專案很多層時不用上面這些換成 VueX 統一管理呼叫。 官方文件 安裝 VueX官方安裝自己是使用 vue gui 這畫面後點下載 VueX ，就安裝好了。 狀態單向資料流.注意順序不要逆向 步驟 state 設定參數。 原本頁面使用 computed 引用。12345computed:&#123; isLoading()&#123; return this.$store.state.isLoading; &#125;&#125; Actions 操作類似 methods。 Mutations 改變 state 的狀態。 Getter 簡化寫法。 Modules 模組化。 嚴謹模式 strict:true寫 VueX 語法不符合規範會跳錯開發階段建議開著.產品階段建議關掉(因為耗資源)可以在不同的模組裡面用 123456export default new Vuex.Store(&#123; strict: true, state: &#123;&#125;, mutations: &#123;&#125;, actions: &#123;&#125;,&#125;)","categories":[{"name":"Vue","slug":"Vue","permalink":"https://teishashu.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://teishashu.github.io/tags/Vue/"},{"name":"VueX","slug":"VueX","permalink":"https://teishashu.github.io/tags/VueX/"}]},{"title":"Nuxt.js","slug":"1-nuxt","date":"2020-08-03T16:00:00.000Z","updated":"2020-08-27T06:31:41.676Z","comments":true,"path":"2020/08/04/1-nuxt/","link":"","permalink":"https://teishashu.github.io/2020/08/04/1-nuxt/","excerpt":"介紹Vue 進階的框架，解決 Vue 開發上的問題把一些設定都已經做好.解決一些繁瑣、需要手刻的部分.使開發更輕鬆完成、上線、穩定","text":"介紹Vue 進階的框架，解決 Vue 開發上的問題把一些設定都已經做好.解決一些繁瑣、需要手刻的部分.使開發更輕鬆完成、上線、穩定 分成3種使用方式.下面3種整合在這工具裡面.原本 SSR 要自己寫. render靠其他工具. spa要靠 vue cli .但是 nuxt 整合在一起 Server Side Rendered做 spa 單頁式網站最大的問題是 seo 比較難處理. vue 有提供 ssr 解決方案.但是 nuxt 處理起來會比較輕鬆。前端會碰到 node.js ，server 這塊。在網頁原始碼裡面會真的看到文字、網頁內容可是用 vue cli 可能會出現 這邊是網頁一開始進來的頁面( google 爬蟲只會爬一次)如果有切換頁面是 Client Side Rendered Statically Generated 靜態產生原本是打 API 產生在頁面上.現在可以把內容形成一個靜態網頁。很適合弄好丟到一個普通空間ex:github靜態檔: 頁面永遠長那樣.畫面不會一直因為 API 一直變動 Single Page Application(SPA)沒有ssr 原本的 vue，如果只做這個可以直接用 vue cli 特色: 自動 code 分割不會全部一個 js 檔.這樣載第一個畫面時跑比較久 Server Side Rendered提供 seo 安裝 安裝好 node.js 用 npx 比較方便create-nuxt-app ```12345678910111213141516171819202122232425262728293031會詢問很多東西.確認按 enter安裝 scss 套件 npm install node-sass sass-loader### 資料夾架構 Directory Structure- assets (會被打包)用到的支援檔.在這邊會壓縮、轉譯(圖片、css、sass、webfonts)- components模組.寫的 vue 檔- layouts排版.版型定位- pages每頁 router 要進的頁面(ex:首頁、產品頁...)透過資料夾結構來呈現router- plugins別人寫的組件 ex: axios、tweenmax...- static (不會被打包)靜態檔 ex:css、圖片不要壓縮的(ico)、js- serverapp.use(nuxt.render) 把 component 跑成網頁給使用者看.優點是只要寫一份前端程式就可以解決.不用寫2份程式用 php 困難的地方在怎麼把前端 vue component 轉譯成真的畫面進入點是 server&#x2F;index.js### 一般網頁調整成 nuxt1. 移動assets 資料夾: img、css、fontstatic 資料夾: ico、js2. 引入上面檔案(link、script)nuxt.config.js 是一個 js 的物件導出引入 js //原本在 html 中 //更改在 nuxt.config.jshead:{ script:[ {src: “/js/jquery.min.js”, body:true}, {src: “/js/browser.min.js”, body:true}, {src: “/js/breakpoints.min.js”, body:true}, {src: “/js/util.js”, body:true}, {src: “/js/main.js”, body:true}, ]} 12引入 css /* Global CSS */ css: [ “~/assets/css/main.css” ], 12345678&lt;b&gt;蚯蚓符號是 nuxt 代表跟目錄&lt;&#x2F;b&gt;注意檔案路徑.有些會不太一樣要確認( main.scss 裡面)### pages 檔案修改首頁資料移過去### 建立 nuxt 的主模板模板上 body 標籤上有元素 ... 123nuxt 無法直接執行 body 上的元素因此在資料夾一進來的地方建一個模板 index.html (vue 中是在 public) 1234567891011121314在重啟一次 npm run dev### 改網站內的連結路徑記得用 ~ 開頭### 修正 main.js 的 bug頁面中 menu 的部分還是跑版在查看上面載入的 js 中發現 main.js 的 menu 地方跟 nuxt 衝突(main.js 是原本版型的運作原理)需要使用生命週期更改先在 layouts&#x2F;default.vue 的 template 下面使用下面這段 export default{ mounted(){ var $window = $(window), $body = $('body'); //copy main.js 的 menu 內容 } } 123456789在把 main.js 中 menu 程式的部分移到上面程式的註解下方的位置重整網頁就可以顯示主要是調整程式跑的前後順序一開始的 main.js 先執行了.可是 el 還沒上去因此這段無法顯示.後來放到 mounted 裡面就抓的到### 增加新頁面- 在 pages 裡面新增一個 generic.vue 檔- 內容 123 123456789- 在網址上增加 &#96;&#96;&#96;&#x2F;generic&#96;&#96;&#96; 看是否可以換過去成功就修改內容在 pages 資料夾中新增檔案優點是可以直接變成有 router### 共用地方變成 component在資料夾 components 中新增.檔案名習慣大寫開頭之後引入到需要的頁面 import Header from \"~/components/Header.vue\"; export default { components: { Header, } } 1頁面使用的地方放上標籤 &#96;&#96;&#96;&lt;Header&#x2F;&gt; nuxt-link 超連結換頁不會重整 傳統作法使用 &lt;a href=&quot;/generic&quot;&gt; 會跳頁變成使用 12&lt;nuxt-link to&#x3D;&quot;&#x2F;generic&quot; class&#x3D;&quot;link-style&quot;&gt;...&lt;&#x2F;nuxt-link&gt; 改好 menu 頁面時發現切換時網頁的ico位置會重新跑這是 menu 原本程式寫法需要修改.移除下面程式 123window.setTimeout(function() &#123; window.location.href &#x3D; href;&#125;, 350); 使用 scss 改原本的樣式在當個頁面使用下面這語法 12&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;&lt;&#x2F;style&gt; nuxt 頁面過渡 (vue transition)在 assets/sass/main.scss 中增加 12345678.page-enter-active,.page-leave-active&#123; transition: opacity 0.27s;&#125;.page-enter,.page-leave-active&#123; opacity: 0;&#125; 移除 assets/sass/layout/_menu.scss 檔案中的 1234#wrapper &#123; @include vendor(&#39;transition&#39;, &#39;opacity #&#123;_duration(menu)&#125; ease&#39;); opacity: 1;&#125; 上傳前修改設定檔到 nuxt.config.js 新增 router 的設定並修改 head 中 script 的路徑] 123456789101112131415router: &#123; base: &#39;&#x2F;repository名稱&#x2F;&#39;&#125;,head: &#123; link: [ &#123; rel: &#39;icon&#39;, type: &#39;image&#x2F;x-icon&#39;, href: &#39;&#x2F;repository名稱&#x2F;favicon.ico&#39; &#125;, ], script:[ &#123;src: &quot;&#x2F;repository名稱&#x2F;js&#x2F;jquery.min.js&quot;, body:true&#125;, &#123;src: &quot;&#x2F;repository名稱&#x2F;js&#x2F;browser.min.js&quot;, body:true&#125;, &#123;src: &quot;&#x2F;repository名稱&#x2F;js&#x2F;breakpoints.min.js&quot;, body:true&#125;, &#123;src: &quot;&#x2F;repository名稱&#x2F;js&#x2F;util.js&quot;, body:true&#125;, &#123;src: &quot;&#x2F;repository名稱&#x2F;js&#x2F;main.js&quot;, body:true&#125;, ]&#125;, 發布前建置打包優化處理 1npm run build 產生靜態檔案.產生一個 dist 檔站 1npm run generate 在上傳到遠端更深的主題 Server side renderspa 網站最大的問題是 SEO，搜尋引擎比較難抓 vue render 出來的資料，所以使用 nuxt 通常是做 SSR 應用就不會用 vue cli 用 spa 網頁文字是透過 vue 組建產生.所以搜尋引擎爬不到文字所以 nuxt 最強是做 SSR 應用","categories":[{"name":"Vue","slug":"Vue","permalink":"https://teishashu.github.io/categories/Vue/"}],"tags":[{"name":"Nuxt","slug":"Nuxt","permalink":"https://teishashu.github.io/tags/Nuxt/"}]},{"title":"RESTful API","slug":"2-RESTful-API","date":"2020-08-03T16:00:00.000Z","updated":"2020-08-27T09:38:50.707Z","comments":true,"path":"2020/08/04/2-RESTful-API/","link":"","permalink":"https://teishashu.github.io/2020/08/04/2-RESTful-API/","excerpt":"目的一套設計規範來協議前後端的API，比較不用花時間猜怎麼使用，送出後會有狀態碼顯示。","text":"目的一套設計規範來協議前後端的API，比較不用花時間猜怎麼使用，送出後會有狀態碼顯示。 三種元件組成： URL定位資源。(不同HTTP動詞有對應的URL寫法.寫在網址的最後面) HTTP動詞描述操作：GET、POST、PUT、DELETE…(有很多種.常用的幾個) Content Types 資源呈現方式：JSON、XML…。 HTTP動詞 中文名稱 備註 GET 獲取.讀取 從伺服器取出資料(一項或多項)。請求展示取得指定的資料 POST 新增 在伺服器新增資料(用在新增的動作store) PUT 更新.替換 跟PATCH類似.一個 DELETE 刪除 destroy - - - PATCH 更新.替換 跟PUT類似.選取的批次。 HEAD ———– 跟GET方法相同，但沒有回應主體（response body） OPTIONS ———– 描述指定資源的溝通方法 每個資源都會有一個 url 位址，利用 url 去做一些事情會使用到 http 動詞 → 一個檔案：變數{id}。多個檔案：陣列方式丟變數。 → 加「?」是非必填，不用加參數。 (思考)為何delete 不是對應 delete 而是 destroy? 請求request 和 操作actions 的指令不同，一開始設定時有分開不要一樣。 4種標準方法： GET、POST、PUT、DELETE 7種RESTful actions：index、new、create、edit、update、show、destroy (使用destroy可以做批次刪除多個檔案) Why the Ruby on Rails action “destroy” is not named “delete”? RESTful一種api架構的標準.規範後的形式固定、可讀性強根據 users 名詞和 http 動詞就可以操作這些資源每個資源都會有一個 url 位址，利用 url 去做事情會使用到 http 動詞。 1.使每個url代表一個資源2.客戶端和服務器之間，傳遞這種資源的某種表現層(分離的好處-單獨開發部互相干擾)狀態有關3.客戶端透過 4個http 動詞對服務氣資源操作(get、post、put、delete) HTTP METHOD 用在什麼情況?網頁使用時.需要透過 HTTP動詞跟伺服器取資料或送資料 HTTP METHOD 請求網址 請求方式 得到資料https://example.com/api/users GET (獲取所有用戶信息)https://example.com/api/users/1 GET (獲取標識爲 1 用戶信息) 新增https://example.com/api/users POST (添加新的用戶) 編輯、更新https://example.com/api/users/1 PATCH (更新標識爲 1 用戶部分信息(批次))https://example.com/api/users/1 PUT (更新標識爲 1 用戶部分信息(一筆資料)) 刪除https://example.com/api/users/1 DELETE (刪除標識爲 1 用戶信息) HTTP 狀態碼也是有規律的 1請求未成功；2請求成功、表示成功處理了請求的狀態代碼；3請求被重定向、表示要完成請求，需要進一步操作。通常，這些狀態代碼用來重定向；4請求錯誤這些狀態代碼表示請求可能出錯，妨礙了服務器的處理；5**（服務器錯誤）這些狀態代碼表示服務器在嘗試處理請求時發生內部錯誤。這些錯誤可能是服務器本身的錯誤，而不是請求出錯。 CORS 是否可以跨網域撈取資料(開啟資料才能共享)撈資料時有時會顯示 Access-Control-Allow-Origin 沒開啟(他擔心有資安問題-如果真的需要撈但是被阻擋時:a.把json格式的資料下載下來自己更新。b.後端PHP、Node.js 的方式來撈取(透過自己寫的後端去撈資料，再渲染到自己的前端)","categories":[],"tags":[{"name":"RESTful API","slug":"RESTful-API","permalink":"https://teishashu.github.io/tags/RESTful-API/"}]},{"title":"Vue - 動態路由 -點按鈕換頁面","slug":"4-vue-route","date":"2020-08-03T16:00:00.000Z","updated":"2020-08-27T06:32:03.676Z","comments":true,"path":"2020/08/04/4-vue-route/","link":"","permalink":"https://teishashu.github.io/2020/08/04/4-vue-route/","excerpt":"params 設定動態路由 在 router/index.js 檔案裏面.要設定動態路由的 path 路徑裡面加上 /:id參數名稱。 1234567const routes &#x3D; [ &#123; path: &#39;product&#x2F;:id&#39;, name: &#39;product&#39;, component: () &#x3D;&gt; import(&#39;..&#x2F;components&#x2F;product&#x2F;product.vue&#39;) &#125;,]","text":"params 設定動態路由 在 router/index.js 檔案裏面.要設定動態路由的 path 路徑裡面加上 /:id參數名稱。 1234567const routes &#x3D; [ &#123; path: &#39;product&#x2F;:id&#39;, name: &#39;product&#39;, component: () &#x3D;&gt; import(&#39;..&#x2F;components&#x2F;product&#x2F;product.vue&#39;) &#125;,] 那個頁面(後面先打其他的資料)網址變成http://localhost:8080/product/4接下來在瀏覽器 f12 中的 vue 可以看到$route 下 params:{ id: “4”} 設定預設的網址設定 redirect 讓網頁沒有設定參數自己指引到這裡 123456789&#123; path: &#39;product&#39;, redirect: &#39;product&#x2F;all&#39;, &#x2F;&#x2F; 預設網址&#125;,&#123; path: &#39;product&#x2F;:id&#39;, name: &#39;product&#39;, component: () &#x3D;&gt; import(&#39;..&#x2F;components&#x2F;product&#x2F;product.vue&#39;)&#125;, 如果參數可有可無的.在參數後面加上? 12345&#123; path: &#39;product&#x2F;:id?&#39;, name: &#39;product&#39;, component: () &#x3D;&gt; import(&#39;..&#x2F;components&#x2F;product&#x2F;product.vue&#39;)&#125;, 抓到動態路由可以在生命週期 created 裡面打this.$route.params.id注意$route要加”$” 123created() &#123; console.log(this.$route.params.id)&#125;, 點按鈕時.讓按鈕的值更換掉 $route.params.id 的部分 1234&#x2F;&#x2F; 先設定點擊不同按鈕時 name 的值會換const name &#x3D; a123;&#x2F;&#x2F; 在輸入下面這個.網址的id就可以換this.$router.push(&#96;&#x2F;product&#x2F;$&#123;name&#125;&#96;); 接下來只要設定內容更換就可以了。 一般比較喜歡使用params來處理網頁參數比較整齊query比較是分頁、臨時使用的id https://ithelp.ithome.com.tw/articles/10197778 https://ithelp.ithome.com.tw/articles/10214449 導航守衛用戶切換頁面才會觸發(單頁重整不會觸發)beforeEach 切換頁面前觸發(要改網址)to 即將要到的頁面， from 來自哪個頁面，next 到達下個頁面 指定頁面需不需要驗證.沒問題用 next 放行。例子:身分驗證有沒有登入在 main.js 最後的地方設定 123456789101112131415161718router.beforeEach((to, from, next) &#x3D;&gt; &#123; if(to.meta.requiresAuth)&#123; &#x2F;&#x2F;這裡需要驗證 const api &#x3D; &#96;$&#123;process.env.VUE_APP_API_PATH&#125;&#x2F;api&#x2F;user&#x2F;check&#96;; &#x2F;&#x2F; 檢查用戶是否登入的 api。 axios.post(api).then(response &#x3D;&gt; &#123; if(response.data.success) &#123; &#x2F;&#x2F;驗證通過 next(); &#125;else&#123; alert(&#39;請先登入&#39;); &#x2F;&#x2F;如果不是登錄的狀態回登錄的頁面..next裡面包個物件 next(&#123; path:&#39;&#x2F;login&#39;, &#x2F;&#x2F;這是 router 那設定的路徑 &#125;); &#125; &#125;); &#125;else&#123; &#x2F;&#x2F;不用驗證的放行 next() &#125;&#125;) 路由需要驗證的部分要加 meta: { requiresAuth: true },透過這個來驗證 123456789101112131415161718&#123; path: &#39;&#x2F;login&#39;, name: &#39;login&#39;, component: () &#x3D;&gt; import(&#39;..&#x2F;components&#x2F;backend&#x2F;admin&#x2F;Login.vue&#39;)&#125;,&#123; path: &#39;&#x2F;admin&#39;, component: () &#x3D;&gt; import(&#39;..&#x2F;components&#x2F;backend&#x2F;admin&#x2F;Admin.vue&#39;), meta: &#123; requiresAuth: true &#125;, children:[ &#123; path: &#39;&#39;, name: &#39;admin_product&#39;, component: () &#x3D;&gt; import(&#39;..&#x2F;components&#x2F;backend&#x2F;admin_product&#x2F;Admin_product.vue&#39;), meta: &#123; requiresAuth: true &#125; &#125;, ]&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://teishashu.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://teishashu.github.io/tags/Vue/"}]},{"title":"JavaScript ES6 的解構賦值","slug":"js-解構賦值","date":"2020-08-03T16:00:00.000Z","updated":"2020-08-06T07:19:05.234Z","comments":true,"path":"2020/08/04/js-解構賦值/","link":"","permalink":"https://teishashu.github.io/2020/08/04/js-%E8%A7%A3%E6%A7%8B%E8%B3%A6%E5%80%BC/","excerpt":"右方資料給到左方陣列裡的數量不夠時剩下的就不會賦值，中間有空就會跳開let [grandpa, , dad, mom, me]","text":"右方資料給到左方陣列裡的數量不夠時剩下的就不會賦值，中間有空就會跳開let [grandpa, , dad, mom, me] 123let family &#x3D; [&#39;阿公&#39;,&#39;阿嬤&#39;,&#39;爸&#39;,&#39;媽&#39;,&#39;我&#39;];let [grandpa, grandma, dad, mom, me] &#x3D; family;console.log(grandpa, grandma, dad, mom, me); 應用: 2個變數交換 1234let aaa &#x3D; &#39;aaa&#39;;let bbb &#x3D; &#39;bbb&#39;;[aaa, bbb] &#x3D; [bbb, aaa];console.log(aaa,bbb) 應用: 字串變陣列 123let str &#x3D; &#39;我在練習中&#39;;let [a, b, c, d, e] &#x3D; str;console.log(a, b, c, d, e) 物件12345678910111213141516let family &#x3D; &#123; dad: &#39;爸&#39;, mom: &#39;媽&#39;, me: &#39;我&#39;&#125;&#x2F;&#x2F; 取出一個值。(物件裡面放值，右邊是上面的物件)let &#123;dad&#125; &#x3D; family;console.log(dad); &#x2F;&#x2F; 顯示 &#39;爸&#39;&#x2F;&#x2F; 取出一個值後，讓它在新變數名稱上(dad是屬性，myFather新變數名稱)&#x2F;&#x2F; 右方 family 先取出 dad 的值，myFather 重新定這變數名稱。let &#123;dad:myFather&#125; &#x3D; family;console.log(dad, myFather);&#x2F;&#x2F; 顯示 dad-&gt;is not defined。 myFather-&gt;&#39;爸&#39;。 複雜情況 123let &#123;dad:myFather, family: [,mom] &#125; &#x3D; &#123;dad: &#39;爸&#39;, family:[&#39;阿姨&#39;, &#39;媽&#39;, &#39;哥哥&#39;, &#39;弟弟&#39;]&#125;;console.log(myFather, mom) &#x2F;&#x2F; 顯示 &#39;爸&#39;,&#39;媽&#39;&#x2F;&#x2F; 雖然很複雜但先看右邊 預設值 1234567let [my &#x3D; &#39;我&#39;, dad &#x3D; &#39;爸&#39;] &#x3D; [&#39;我誰&#39;]console.log(my, dad)&#x2F;&#x2F; 顯示 &#39;我誰&#39;, &#39;爸&#39;&#x2F;&#x2F; 後面只有1個所以第一個不是用預設值let &#123;damily:my &#x3D; &#39;我&#39;&#125; &#x3D; &#123;&#125;&#x2F;&#x2F;右邊沒傳值，物件會變成&#123;my: &#39;我&#39;&#125; 也可以這樣用有時候一個位置要放2個參數.就用物件的方式傳入裡面的參數可以直接使用 123abc(context, &#123;id, item&#125;)&#123; console.log(context, id, item);&#125;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://teishashu.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://teishashu.github.io/tags/Javascript/"}]},{"title":"非同步(異步)","slug":"3-AJAX-異部","date":"2020-08-03T16:00:00.000Z","updated":"2020-08-27T06:31:52.634Z","comments":true,"path":"2020/08/04/3-AJAX-異部/","link":"","permalink":"https://teishashu.github.io/2020/08/04/3-AJAX-%E7%95%B0%E9%83%A8/","excerpt":"前言在 JavaScript 中程式一次只執行一件事情，非同步的特色: 全部程式執行完.最後才會執行。(事情先放到 “event queue 事件佇列” 裡面)有時間差.沒辦法確定什麼時間開始執行、完畢。","text":"前言在 JavaScript 中程式一次只執行一件事情，非同步的特色: 全部程式執行完.最後才會執行。(事情先放到 “event queue 事件佇列” 裡面)有時間差.沒辦法確定什麼時間開始執行、完畢。 非同步程式:setTimeout、addEventListener、AJAX相關…(需要花時間等待.但主要程式不會等。) 解決方式3種: Callbacks(回呼函式) Promise(物件-承諾) Async(語法-非同步)/ Await(等待) 範例 1.一般同步的程式 1234567891011&lt;button type&#x3D;&quot;button&quot; onclick&#x3D;&quot;clickFun()&quot;&gt;click&lt;&#x2F;button&gt;&lt;script&gt; function number(n1, n2)&#123; return n1+n2; &#125; function clickFun()&#123; let res &#x3D; number(4, 8); console.log(res); &#x2F;&#x2F; 12 &#125;&lt;&#x2F;script&gt; 範例 2.加入非同步的程式 123456789101112function number(n1, n2, delayTime)&#123; console.log(&#39;a&#39;) setTimeout(function()&#123; &#x2F;&#x2F;加入非同步程式 console.log(&#39;b&#39;) return n1+n2; &#125;,delayTime); console.log(&#39;c&#39;)&#125;function clickFun()&#123; let res &#x3D; number(4, 8, 2000); console.log(res); &#x2F;&#x2F;undefined&#125; 顯示順序: a c undefined b 為了解決上面抓不到值、時間順序的問題.有下面3種方法把資料抓出來。 Callbacks(回呼函式)使用函式當參數用。 (第9行是一個函式當參數傳遞到第一行的 callback 這參數使用。第3行是利用這參數名稱呼叫，把值回傳回去，所以第10行才有結果。)按了之後要等設定的2秒鐘.才會回傳對的值。 123456789101112function number(n1, n2, delayTime, callback)&#123; setTimeout(function()&#123; callback(n1+n2); &#x2F;&#x2F;把資料帶出去 &#125;,delayTime);&#125;function clickFun()&#123; &#x2F;&#x2F; 刪除 let res &#x3D; number(4, 8, 2000); &#x2F;&#x2F; 整個換掉 number(4, 8, 2000, function(res)&#123; console.log(res); &#x2F;&#x2F;undefined &#125;)&#125; Promise(物件-承諾)要使用 return 123456789101112function number(n1, n2, delayTime, callback)&#123; setTimeout(function()&#123; callback(n1+n2); &#x2F;&#x2F;把資料帶出去 &#125;,delayTime);&#125;function clickFun()&#123; &#x2F;&#x2F; 刪除 let res &#x3D; number(4, 8, 2000); &#x2F;&#x2F; 整個換掉 number(4, 8, 2000, function(res)&#123; console.log(res); &#x2F;&#x2F;undefined &#125;)&#125;","categories":[{"name":"AJAX","slug":"AJAX","permalink":"https://teishashu.github.io/categories/AJAX/"}],"tags":[{"name":"AJAX","slug":"AJAX","permalink":"https://teishashu.github.io/tags/AJAX/"}]},{"title":"Select 改樣式 - 用 ul、li 改寫","slug":"select","date":"2020-08-02T16:00:00.000Z","updated":"2020-08-03T13:39:25.563Z","comments":true,"path":"2020/08/03/select/","link":"","permalink":"https://teishashu.github.io/2020/08/03/select/","excerpt":"有時候想改更多 select 的樣式但原本 select、option 標籤能改的有限.因此換成使用 ul、li 重新構成選單。 請選擇地區 const liAry = ['北部','中部','南部','東部','離島']; const selectUl = document.querySelector('#list'); const selectLi = document.querySelector('#list li'); const selectName = document.querySelector('#selectName'); //list let html_list = \"\"; liAry.forEach(el => { html_list+= `${el}`; }) selectUl.innerHTML = html_list; //click toggle function toggleFun(){ if(selectUl.className === ''){ selectUl.classList.add('d-none'); }else{ selectUl.classList.remove('d-none'); } } function listMouseLeave(){ selectUl.classList.add('d-none'); } // click li selectUl.addEventListener('click',function(e){ selectName.innerHTML = e.target.innerText; selectUl.classList.add('d-none'); }) .d-none{ display:none; } .select{ margin-top: 1rem; margin-bottom: 30px; position: relative; } .select div{ cursor: pointer; display: flex; justify-content: space-between; align-items: center; padding: 7px 15px; border-width: 2px; border-style: solid; border-color: #569784 #569784 #a2cabf #a2cabf; } .select ul{ cursor: pointer; border-width: 2px; border-style: solid; border-color: #569784 #569784 #a2cabf #a2cabf; position: absolute; top: 35px; left: 0; background-color: #fff; width: 100%; z-index: 30; padding-left: 0; list-style: none; box-sizing: border-box; /* height: 230px; overflow-y: scroll; */ } .select li{ cursor: pointer; padding: 4px 15px; } .select li:hover{ background-color: #a2cabf; }","text":"有時候想改更多 select 的樣式但原本 select、option 標籤能改的有限.因此換成使用 ul、li 重新構成選單。 請選擇地區 const liAry = ['北部','中部','南部','東部','離島']; const selectUl = document.querySelector('#list'); const selectLi = document.querySelector('#list li'); const selectName = document.querySelector('#selectName'); //list let html_list = \"\"; liAry.forEach(el => { html_list+= `${el}`; }) selectUl.innerHTML = html_list; //click toggle function toggleFun(){ if(selectUl.className === ''){ selectUl.classList.add('d-none'); }else{ selectUl.classList.remove('d-none'); } } function listMouseLeave(){ selectUl.classList.add('d-none'); } // click li selectUl.addEventListener('click',function(e){ selectName.innerHTML = e.target.innerText; selectUl.classList.add('d-none'); }) .d-none{ display:none; } .select{ margin-top: 1rem; margin-bottom: 30px; position: relative; } .select div{ cursor: pointer; display: flex; justify-content: space-between; align-items: center; padding: 7px 15px; border-width: 2px; border-style: solid; border-color: #569784 #569784 #a2cabf #a2cabf; } .select ul{ cursor: pointer; border-width: 2px; border-style: solid; border-color: #569784 #569784 #a2cabf #a2cabf; position: absolute; top: 35px; left: 0; background-color: #fff; width: 100%; z-index: 30; padding-left: 0; list-style: none; box-sizing: border-box; /* height: 230px; overflow-y: scroll; */ } .select li{ cursor: pointer; padding: 4px 15px; } .select li:hover{ background-color: #a2cabf; } 使用 Vue.js 的方式html架構12345678910111213141516&lt;div class&#x3D;&quot;select&quot;&gt; &#x2F;&#x2F; 顯示的地方 &lt;div @click&#x3D;&quot;selectToggle &#x3D; !selectToggle&quot;&gt; &#123;&#123;selectArea&#125;&#125; &lt;i class&#x3D;&quot;fas fa-caret-down&quot;&gt;&lt;&#x2F;i&gt; &lt;&#x2F;div&gt; &#x2F;&#x2F; 下拉區域 &#x2F;&#x2F; mouseleave &#x3D;&gt; 滑鼠移開下拉要關起來 &lt;ul v-show&#x3D;&quot;selectToggle&quot; @mouseleave&#x3D;&quot;selectToggle &#x3D; false&quot;&gt; &lt;li v-for&#x3D;&quot;(item,index) in counties&quot; :key&#x3D;&quot;item.SiteId&quot; @click&#x3D;&quot;selectFunction(item)&quot;&gt; &#123;&#123;item&#125;&#125; &lt;&#x2F;li&gt; &lt;&#x2F;ul&gt;&lt;&#x2F;div&gt; scss 樣式123456789101112131415161718192021222324252627282930313233343536$primary-green: #569784;.select&#123; margin-top: 1rem; margin-bottom: 30px; position: relative; div&#123; cursor: pointer; width: 100%; display: flex; justify-content: space-between; align-items: center; padding: 7px 15px; border-width: 2px; border-style: solid; border-color: $primary-green $primary-green lighten($primary-green,25%) lighten($primary-green,25%); &#125; ul&#123; cursor: pointer; border-width: 2px; border-style: solid; border-color: $primary-green $primary-green lighten($primary-green,25%) lighten($primary-green,25%); position: absolute; top: 40px; left: 0; background-color: #fff; width: 100%; z-index: 30; &#125; li&#123; cursor: pointer; padding: 4px 15px; &amp;:hover&#123; background-color: lighten($primary-green,40%); &#125; &#125;&#125; vue 的程式部分1234567891011121314151617181920212223data: &#123; allData:[], &#x2F;&#x2F; 預先的所有資料 nowData:[], &#x2F;&#x2F; 現在塞選過使用的資料 selectToggle:false, &#x2F;&#x2F; 下拉選單的切換 selectArea:&#39;請選擇地區&#39;, &#x2F;&#x2F; 選擇後的文字顯示 &#125;,methods: &#123; selectFunction(item)&#123; &#x2F;&#x2F; 點擊下拉選單後塞選資料 const nowSelectArea &#x3D; []; this.allData.forEach(el &#x3D;&gt; &#123; if(el.County &#x3D;&#x3D;&#x3D; item)&#123; nowSelectArea.push(el) &#125; &#125;) this.nowData &#x3D; nowSelectArea; &#x2F;&#x2F; 現在塞選過的資料 this.selectArea &#x3D; item; &#x2F;&#x2F; select 顯示的文字 this.selectToggle &#x3D; false; &#x2F;&#x2F; 點選下拉選單後.讓選單關閉 this.sortPage(this.nowData); &#x2F;&#x2F;重新整理頁面.顯示新的資料 &#125;,&#125;, 使用 Javascript 的方式html架構12345678&lt;div class&#x3D;&quot;select&quot;&gt; &lt;div onclick&#x3D;&quot;toggleFun()&quot;&gt; &lt;span id&#x3D;&quot;selectName&quot;&gt;請選擇地區&lt;&#x2F;span&gt; &lt;i class&#x3D;&quot;fas fa-caret-down&quot;&gt;&lt;&#x2F;i&gt; &lt;&#x2F;div&gt; &lt;ul id&#x3D;&quot;list&quot; class&#x3D;&quot;d-none&quot; onmouseleave&#x3D;&quot;listMouseLeave()&quot;&gt; &lt;&#x2F;ul&gt;&lt;&#x2F;div&gt; css 樣式把上面 scss 的巢狀拆開，並加入下面這個 class 123.d-none&#123; display:none;&#125; javascript 程式的部分123456789101112131415161718192021222324252627282930const liAry &#x3D; [&#39;北部&#39;,&#39;中部&#39;,&#39;南部&#39;,&#39;東部&#39;,&#39;離島&#39;];const selectUl &#x3D; document.querySelector(&#39;#list&#39;);const selectLi &#x3D; document.querySelector(&#39;#list li&#39;);const selectName &#x3D; document.querySelector(&#39;#selectName&#39;);&#x2F;&#x2F;listlet html_list &#x3D; &quot;&quot;;liAry.forEach(el &#x3D;&gt; &#123; html_list+&#x3D; &#96;&lt;li&gt;$&#123;el&#125;&lt;&#x2F;li&gt;&#96;;&#125;)selectUl.innerHTML &#x3D; html_list;&#x2F;&#x2F;click togglefunction toggleFun()&#123; if(selectUl.className &#x3D;&#x3D;&#x3D; &#39;&#39;)&#123; selectUl.classList.add(&#39;d-none&#39;); &#125;else&#123; selectUl.classList.remove(&#39;d-none&#39;); &#125;&#125;function listMouseLeave()&#123; selectUl.classList.add(&#39;d-none&#39;);&#125;&#x2F;&#x2F; click liselectUl.addEventListener(&#39;click&#39;,function(e)&#123; selectName.innerHTML &#x3D; e.target.innerText; selectUl.classList.add(&#39;d-none&#39;);&#125;)","categories":[{"name":"CSS","slug":"CSS","permalink":"https://teishashu.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://teishashu.github.io/tags/CSS/"},{"name":"Vue","slug":"Vue","permalink":"https://teishashu.github.io/tags/Vue/"}]},{"title":"網頁動畫、特效(2)- Gsap3 + Vue.js","slug":"animate-gasp","date":"2020-07-16T16:00:00.000Z","updated":"2020-08-03T07:12:28.571Z","comments":true,"path":"2020/07/17/animate-gasp/","link":"","permalink":"https://teishashu.github.io/2020/07/17/animate-gasp/","excerpt":"介紹GSAP3：專門處理動畫與特效的 JS 套件 安裝官方各種安裝方式","text":"介紹GSAP3：專門處理動畫與特效的 JS 套件 安裝官方各種安裝方式 npm 安裝 1npm install gsap 引入專案中上面官方網站 npm 安裝的部分有些插件可以挑選.這次需要 ScrollTrigger (頁面滑到才動)另外目前設定只有專案的首頁需要用到.所以在那 component 頁面打下面的指令引入 3行。 1234567&lt;script&gt;import &#123; gsap &#125; from &quot;gsap&quot;;import &#123; ScrollTrigger &#125; from &quot;gsap&#x2F;ScrollTrigger&quot;;gsap.registerPlugin(ScrollTrigger);export default &#123;...&#125;&lt;&#x2F;script&gt; 使用方式gsap 是使用 id 或 class 操作動畫。 公式12345678910111213gsap.method(&#39;selector&#39;, &#123;&#125;);&#x2F;&#x2F; 使用例子 1gsap.to(&quot;.a&quot;, &#123;color: &#39;#ccc&#39;, duration: 2&#125;);&#x2F;&#x2F; 使用例子 2gasp.from (&quot;.a&quot;, &#123; duration:3, x:&quot;-50vw&quot;, rotation:-300, ease:&quot;linear&quot;, scrollTrigger:&#123; trigger:&quot;.a&quot;, markers:true &#125;&#125;) 測試專案 gsap 是否安裝成功(成功的話 #h1 出現在畫面中會右移) 12345678910111213141516&lt;template&gt; &lt;div&gt; &lt;h1 id&#x3D;&quot;h1&quot;&gt;我是標題&lt;&#x2F;h1&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123; gsap &#125; from &quot;gsap&quot;;import &#123; ScrollTrigger &#125; from &quot;gsap&#x2F;ScrollTrigger&quot;;gsap.registerPlugin(ScrollTrigger);export default &#123; mounted() &#123; gsap.to(&quot;#h1&quot;, &#123;x: 100, duration: 1&#125;); &#125;&#125;&lt;&#x2F;script&gt; ScrollTrigger 滾動觸發Introducing ScrollTrigger for GSAP 注意: scrollTrigger (要小寫s開頭).不然會顯示找不到這插件 ! 1234567891011gsap.to(&quot;#h1&quot;, &#123; &#x2F;&#x2F;要觸發的元素 scrollTrigger:&#123; &#x2F;&#x2F;頁面滑動觸發設定 trigger: &quot;#product1&quot;, &#x2F;&#x2F;要觸發的元素 start: &quot;top center&quot;, &#x2F;&#x2F;第一個值:元素的開始位置，第二個值:畫面的位置 end: &quot;bottom 100px&quot; &#x2F;&#x2F; 同 start 用法 marker: true, &#x2F;&#x2F;顯示提示字.會顯示設定、物件的開始結束 toggleActions: &quot;restart none none none&quot; &#x2F;&#x2F;切換動作 &#125;, x: 400, &#x2F;&#x2F;外部這是要改變的效果 duration:2&#125;); start 可放的值top、center、bottom、pixels、percentages(relative to top) toggleActions 可以放4個值.依序跑 值 說明 play 只跑一次 pause 暫停 resume 繼續 reverse 逆轉 restart 重複跑 reset 重置 complete 完成 none 無","categories":[{"name":"Gsap","slug":"Gsap","permalink":"https://teishashu.github.io/categories/Gsap/"}],"tags":[{"name":"網頁特效","slug":"網頁特效","permalink":"https://teishashu.github.io/tags/%E7%B6%B2%E9%A0%81%E7%89%B9%E6%95%88/"},{"name":"Gsap","slug":"Gsap","permalink":"https://teishashu.github.io/tags/Gsap/"},{"name":"Vue","slug":"Vue","permalink":"https://teishashu.github.io/tags/Vue/"}]},{"title":"網頁動畫、特效(1)- Animation、Transition","slug":"animate-animation-transition","date":"2020-07-14T16:00:00.000Z","updated":"2020-07-16T11:19:32.780Z","comments":true,"path":"2020/07/15/animate-animation-transition/","link":"","permalink":"https://teishashu.github.io/2020/07/15/animate-animation-transition/","excerpt":"前言製作網頁的動畫、特效以前是用 JavaScript、Flash，後來 css3 增加了一些屬性，變成開發時間可以縮短，透過 css 交給瀏覽器處理也比較不吃資源。","text":"前言製作網頁的動畫、特效以前是用 JavaScript、Flash，後來 css3 增加了一些屬性，變成開發時間可以縮短，透過 css 交給瀏覽器處理也比較不吃資源。 要把效果做好有幾個關鍵字可以研究： 動畫：css Animation 過度、轉場：css Transition 變形：transform 2D、transform 3D基本的有概念後就可以開始找範例解析試模仿寫看看。 這次紀錄研究 Animation、Transition 後，搭配 scrollmagic、gsap，讓網頁使用起來多點效果不那麼死硬的過程，transform 這次比較用不到所以先跳過。 CSS3 Animation動畫也稱為影格動畫，可以設定比較細緻的效果。動畫是直接執行的。 語法簡寫順序1animation: [name 名稱] [duration 時間] | [timing-function 執行效果] | [delay 延遲] | [iteration-count 重複次數] | [direction 方向] | [fill-mode 播放前後模式] | [play-state 播放狀態]; 要搭配關鍵影格 @keyframes 才可以用，畢竟沒有時間設定開始結束做什麼無法跑呀。 屬性 說明 補充 animation-name 名稱。@keyframes 後面的名稱 @keyframes 搭配 from、to。 animation-duration 執行時間(s 秒或 ms 毫秒)，預設0 animation-timing-function 執行效果(速度曲線) w3schools animation-delay 延遲(間隔多久後開始)，預設0 animation-iteration-count 重覆執行次數，預設 1 infinite 無限次 animation-direction 執行方向。預設 normal reverse 反向、alternate 先正後反、alternate-reverse先反後正 animation-fill-mode 播放前後模式，預設 none forwards、backwards、both animation-play-state 播放或暫停狀態，預設 running paused 暫停 @keyframes 關鍵影格設定方式 公式 1234@keyframes 動畫名稱 &#123; 時間1 &#123;css 樣式&#125; 時間2 &#123;css 樣式&#125;&#125; 注意動畫名稱大小寫，不同大小寫是不同字。 123&#x2F;&#x2F; 下面2個是不同的動畫@keyframes Abc&#123;&#125;@keyframes ABC&#123;&#125; 設定時間有2種方式: from、to : 一開始和最後的效果(0%、100%)1234@keyframes animate1 &#123; from &#123;background-color:red; margin-left:0;&#125; to &#123;background-color:black; margin-left:50px;&#125;&#125; 0-100% : 幾 % 時做什麼事12345@keyframes animate2 &#123; 0% &#123;background-color:red; margin-left:0;&#125; 50% &#123;background-color:blue; margin-left:100px;&#125; 100% &#123;background-color:black; margin-left:50px;&#125;&#125; 套用效果 .animate123{ width:50px; height:50px; animation: animate2 3s ease 1s infinite alternate; background-color:red; margin-bottom:10px; } @keyframes animate2 { 0% {background-color:red; margin-left:0;} 50% {background-color:blue; margin-left:100px;} 100% {background-color:black; margin-left:50px;} } 123456789101112div&#123; width:50px; height:50px; animation: animate2 3s ease 1s infinite alternate; background-color:red;&#125;@keyframes animate2 &#123; 0% &#123;background-color:red; margin-left:0;&#125; 50% &#123;background-color:blue; margin-left:100px;&#125; 100% &#123;background-color:black; margin-left:50px;&#125;&#125; 完整解析 CSS 動畫 Animate.cssCSS3 Animate 有太多要設定，有人整理成一個css檔方便使用，只要會引用、使用就可以操作。Animate.css Vue.js中使用方式animate.css在vue项目中的使用 操作流程: 下載安裝 在想要動畫的地方放 css，每個想要的特效前面都要加animate__animated。 1&lt;h1 class&#x3D;&quot;title animate__animated animate__bounce&quot;&gt;title&lt;&#x2F;h1&gt; 如果希望可以調整的更多.有2種方式:a. 在設定的 css 上面寫 animation 就可以控制 12345&lt;style&gt; .title&#123; animation-duration: 2s; &#125;&lt;&#x2F;style&gt; b. 也可以在原本的地方增加其他 css 屬性 1&lt;h1 class&#x3D;&quot;title animate__animated animate__bounce animate__faster&quot;&gt;title&lt;&#x2F;h1&gt; 效果 屬性名稱 成效 延遲 animate__delay-2sanimate__delay-3sanimate__delay-4sanimate__delay-5s 2s3s4s5s 速度 animate__slowanimate__sloweranimate__fastanimate__faster 2s3s800ms500ms 重複 animate__repeat-1animate__repeat-2animate__repeat-3animate__infinite 123infinite(無限重複) CSS3 Transition 語法動畫效果需要觸發、只能跑一次，適合用在頁面轉場。 語法簡寫順序1transition: [property 名稱] [duration 時間] [timing-function 特效] [delay 延遲] ; 屬性 說明 transition-property 名稱 (放要變的class名稱) transition-duration 執行時間 transition-timing-function 執行的速度曲線 transition-delay 延遲，多久後執行 transition transition-timing-function 漸變函式動畫變換的速度 漸變函式 貝茲曲線 效果 ease cubic-bezier (0.25, 0.1, 0.25, 1.0) 慢(剛起跑緩衝) &gt; 快 &gt; 慢(剎車感) linear cubic-bezier (0.0, 0.0, 1.0, 1.0) 速度不變.平平的 ease-in cubic-bezier (0.42, 0, 1.0, 1.0) 慢(吃力的起床) &gt; 快(快遲到了) ease-out cubic-bezier (0, 0, 0.58, 1.0) 快 &gt; 慢(剎車感) ease-in-out cubic-bezier (0.42, 0, 0.58, 1.0) 慢(吃力的起床) &gt; 快 &gt; 慢(剎車感) 想要其他的線性可以使用下面的網站自己調看看4個數字組成，0~1之間貝茲曲線 套用效果 .transition123{ width:50px; height:50px; background-color:red; margin-bottom:10px; } .transition123:hover{ background-color:blue; margin-left:30px; transition: background-color 3s; transition: margin-left 3s; } (滑鼠請移到方塊上) div{ width:50px; height:50px; background-color:red; margin-bottom:10px; } div:hover{ background-color:blue; margin-left:30px; transition: background-color 3s; transition: margin-left 3s; } //寫很多屬性時可以下面這樣 div:hover{ background-color:blue; margin-left:30px; transition-property: background-color, margin-left; transition-duration: 3s, 1s; }更多 Transition 的搭配使用 比較 Animation、Transition 差異 屬性 特色差異 Animation 1. 網頁載入直接執行特效。2. 可設定較細的動畫效果(關鍵影格.設定很多時間點) Transition 1. 需要事件觸發才能執行特效。(滑鼠、鍵盤事件) 2. 只能設定一開始跟結束的效果中間無法。3. 一次性無法重複 (除非一直觸發才能重複) 他們簡寫的前4個順序一樣，但只要寫前面2個就可以跑了。 animation:name duration timing-function delayiteration-count direction fill-mode play-state; transition:property duration timing-function delay;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://teishashu.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://teishashu.github.io/tags/CSS/"},{"name":"網頁特效","slug":"網頁特效","permalink":"https://teishashu.github.io/tags/%E7%B6%B2%E9%A0%81%E7%89%B9%E6%95%88/"}]},{"title":"Source maps 筆記","slug":"source-maps","date":"2020-07-01T16:00:00.000Z","updated":"2020-07-07T09:36:54.047Z","comments":true,"path":"2020/07/02/source-maps/","link":"","permalink":"https://teishashu.github.io/2020/07/02/source-maps/","excerpt":"直播的筆記與其他的整理前端工程師不可不知的 Source Maps 應用技巧 什麼是 Source maps(原始碼地圖、來源對應)產生 *.map 的檔案","text":"直播的筆記與其他的整理前端工程師不可不知的 Source Maps 應用技巧 什麼是 Source maps(原始碼地圖、來源對應)產生 *.map 的檔案會紀錄原始碼關鍵字和座標(第幾行的位置)。css、js都支援 Source maps主要給瀏覽器用 (用途)網站上使用的 min 壓縮檔透過 map 找到原始檔案的位置來修改維護。 瀏覽器對壓縮最佳化的 js 解壓縮 自動格式化原始碼(google 擴充套建 PrettyPrint)網頁左上角應用程式-&gt;現在應用程式商片-&gt;進去搜尋 f12 的 Sources 點要使用的 min.js再點『{}』就可以解析 (在程式碼那塊的左下角) 如果壓縮檔的名稱有壓過會變成很簡易的代號.不容易看懂.這時就需要使用 Source maps 來產生 *.map 檔跟原始檔連結 Source maps 方式 (偵錯時使用)先下載要使用的工具(直播中使用 uglify-js)再用下面的方式成功在網頁上.會先讀入壓縮檔自動轉換成原始檔顯示 (方法一) 壓縮檔與 map 連結在壓縮檔 *.min.js 的最後一行打(同樣位置) 1&#x2F;&#x2F;# sourceMappingURL&#x3D;*.min.js.map (不同位置) 1&#x2F;&#x2F;# sourceMappingURL&#x3D;&#x2F;path&#x2F;to&#x2F;*.min.js.map 缺點是要手動在 min.js 最後加入這個 (方法二) 在 http header 加入程式碼1X-SourceMap: &#x2F;path&#x2F;to&#x2F;*.js.map 更改完原始的 js 後要再重新產生新的壓縮 js 和 Source maps 才會生效 檔案壓縮是為了網頁的效能JS 最佳化: 合併 多個js檔合併一個(越多js檔網頁跑越慢) 減少 HTTP 要求次數來提升瀏覽效率 壓縮 js中多餘的空白字刪除 過長的區域變數變短(改掉原本的名稱.所以需要用Source maps.只用PrettyPrint 可能還會看不懂。ex: event變n) 縮小檔案加快檔案的下載速度 常用工具: uglify-js、webpack module bundler、TypeScript、Babelcli裡面也有 目標: 縮小檔案大小，降低網路流量 讓變數及函式名稱變成無意義文字，讓別人不容易反推程式邏輯(js是送到用戶端，網站上線時需要加工處理。) 其他debugger js會停下來.接下來一步步的執行開發時不要用壓縮.上線在用.但通常上線才發現bug!才會需要用 Source maps","categories":[],"tags":[{"name":"source maps","slug":"source-maps","permalink":"https://teishashu.github.io/tags/source-maps/"}]},{"title":"Hexo 建立部落格(4) - NexT 美化","slug":"hexo-change-theme-2","date":"2020-07-01T08:21:43.000Z","updated":"2020-07-16T04:27:20.835Z","comments":true,"path":"2020/07/01/hexo-change-theme-2/","link":"","permalink":"https://teishashu.github.io/2020/07/01/hexo-change-theme-2/","excerpt":"文章日期自己設定原本日期是顯示檔案生成的時間，可以改成自己寫好的日期。 文章的檔名前面加上日期ex: 2020-01-01-oneBlog.md","text":"文章日期自己設定原本日期是顯示檔案生成的時間，可以改成自己寫好的日期。 文章的檔名前面加上日期ex: 2020-01-01-oneBlog.md 在 _config.yml 檔案的 #Writing 下面的 # new_post_name: :title.md 改成1new_post_name: :year-:month-:day-:title.md 自定義 css 在 themes/next/source/css 中建立 _mycss.styl 檔案放自己想要新增的。 引入檔案，在 main.styl 中的最後加上下面程式碼。1@import &quot;_mycss.styl&quot;; 大頭照設定找到這個檔案 themes/next/source/images/avatar.gif把自己的大頭蓋過去.可以改副檔名 到主題下的 _config.yml 改路徑 12avatar: url: &#x2F;images&#x2F;avatar.jpg 推薦插件搜尋 search 直接在終端機打下面的指令安裝 1npm install hexo-generator-search --save 在主題下的 _config.yml 中.下面 enable: false 改 true 12local_search: enable: true 留言板 disqus照下面這安裝就可以呈現.只是不能在首頁看有沒有效果Hexo添加Disqus评论 sitemaphexo-generator-sitemap 推薦的網站Hexo-NexT 主题个性优化 修改的主題上傳到 github這邊卡了一下，沒看過 github 上 themes 裡面資料夾會指到另一個地方過程中感覺快把 git 弄壞了.後來有個感想是不要照網路上的亂弄要懂自己在打什麼 XD ~ 之前都是先試在來理解 Hexo Next 主题上传到Github中去以后无法点击查看文件？pull下来也是空白的？【狀況題】如何在 Git 裡刪除檔案或變更檔名？ 看很多文章後發現都有 git rm –cached 相關的指令 我的作法是 把 next 裡面的 git 資料夾刪除 下指令把遠端的指向拿掉1git rm --cached themes&#x2F;next 重新提交123git add .git commit -m&quot;delete&quot;git push (完成) 如果過程中很卡一直在循環可以還原一下 123git add .git git reset --hard HEADgit status &#x2F;&#x2F; 查看一下目前狀況 心得整個弄下來花好幾天了，開始打算寫部落格或想換平台 Hexo 從來都不是首選，因緣際會下對 git、markdown 更了解後，再加上想彈性一點的平台就想說來挑戰試試看，沒想到還弄得起來!!過程中發現自己看文件的掌握比以前好很多，問題搜尋關鍵字嚇得更準確不會查半天查不到，此外在改樣式的過程中觀察到模板是怎麼設計程式和結構，讓我覺得很佩服!蠻開心在過程中學到很多，也發現問題一定要解決不然做不同的專案都會卡一樣的東西。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://teishashu.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://teishashu.github.io/tags/Hexo/"}]},{"title":"Hexo 建立部落格(3) - 更換主題","slug":"hexo-change-theme","date":"2020-06-26T16:00:00.000Z","updated":"2020-07-16T04:25:04.978Z","comments":true,"path":"2020/06/27/hexo-change-theme/","link":"","permalink":"https://teishashu.github.io/2020/06/27/hexo-change-theme/","excerpt":"前言Hexo Themes 裡面有很多的版型可以選擇，一開始的預設主題是 landscape，查詢過程中發現目前最熱門、支援最多的是 NexT 就來用用看!","text":"前言Hexo Themes 裡面有很多的版型可以選擇，一開始的預設主題是 landscape，查詢過程中發現目前最熱門、支援最多的是 NexT 就來用用看! 安裝主題根據 NexT 官方文件來安裝。 下載 NexT Theme 1git clone https:&#x2F;&#x2F;github.com&#x2F;iissnan&#x2F;hexo-theme-next themes&#x2F;next 下載完.查看themes裡面的資料夾是不是多個next的資料夾。 在 _config.yml 檔案裡把 theme: landscape 改換主題 1theme: next 本地端預覽 1hexo s 注意可能有暫存.如果沒更換可以用無痕開啟網頁。 版型調整在 themes/next/layout 資料夾中的檔案.不同版型的檔案類型也不同.花一些時間了解他的邏輯 + 樣板語言就可以改 (其他詳細記錄在下一篇) 上傳到遠端自動生成靜態網暫並上傳遠端 1hexo d 注意上傳的網址路徑.錯誤會跑版.如果跑掉只要在網頁的 _config.yml 設定 root 。 我是用 github如果靜態網頁是上傳到 master，只要設定成 1root: &#x2F; 如果 master 是放資料，靜態網頁是在 gh-pages 上的話 1root: &#x2F;專案名稱&#x2F; 記得這邊有時候還是要更新 master 的程式資料","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://teishashu.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://teishashu.github.io/tags/Hexo/"}]},{"title":"Hexo 建立部落格(2) - 創立部落格","slug":"hexo-created","date":"2020-06-25T16:00:00.000Z","updated":"2020-07-16T04:34:48.863Z","comments":true,"path":"2020/06/26/hexo-created/","link":"","permalink":"https://teishashu.github.io/2020/06/26/hexo-created/","excerpt":"為何選 Hexo 建部落格?一開始是使用 google blogger 想要專注寫文章筆記，後來會 markdown 發現這很快能呈現有編排的樣子，加上想把原本的文章重新整理，因此挑選時想找調整彈性比較大的部落格就挑到這個。","text":"為何選 Hexo 建部落格?一開始是使用 google blogger 想要專注寫文章筆記，後來會 markdown 發現這很快能呈現有編排的樣子，加上想把原本的文章重新整理，因此挑選時想找調整彈性比較大的部落格就挑到這個。 優點:使用 markdown 用一些元素就可以把版面呈現很好、中文文件多(主要開發者是華人)缺點:圖片連結需要另外用(可以搭配 Firebase) 安裝並建立專案 安裝 git 安裝 node.js 安裝 hexo (步驟在下面) 1. 安裝hexo1npm install -g hexo-cli 2. 建立專案資料夾123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 也可以建個資料夾後.在裡面打 12hexo initnpm install 資料夾中會產生下面這些文件 node_modules scaffolds 範例(可忽略) source 放文章(放在_post資料夾裡面) themes 安裝主題時用 .gitignore 上傳 git 時忽略上傳的檔案 package.json 套件管理3. 本地端瀏覽在終端機下指令-本地端預覽(s是serve的縮寫) 1hexo s 會出現 http://localhost:4000/打開後會出現下面這預設的部落格 部落格部屬到遠端 github 上1. 上傳整個專案a. 建立 git 專案 b. 在 .gitignore 資料夾中寫 12node_modules&#x2F;themes&#x2F; 忽略上面2個資料夾.因為 node_modules 檔案太大，themes等等要改主題所以先不要上傳在專案的終端機打下面 git 指令不清楚可以查看 git 相關資料 12345git initgit add .git commit -m&quot;create project&quot;git remote add origin &lt;url&gt;git push -u origin master 2. 上傳 hexo 的部落格a. 設定路徑修改 _config.yml (網站配置文件)裡面的 deploy把檔案推到 gh-pages 這分支上 1234deploy: type: git branch: gh-pages repo: &lt;儲存庫的路徑&gt; b. 打指令上傳遠端 12&#x2F;&#x2F; 上傳遠端.部署上去 (生成靜態網頁，並上傳遠端)hexo d 如果上面指令無法的話.第一次上傳需要下面這個 1234567&#x2F;&#x2F; 生成靜態網頁.檔案會出現 public 資料夾hexo g&#x2F;&#x2F; 第一次需要這樣.之後可以省略這步驟npm install hexo-deployer-git --savehexo d c. 上傳後如果網頁整個跑版(需要檢查路徑) 在 _config.yml 中改相對路徑 true 1relative_link:true 如果是上傳到 github 上，因為網站是存在子目錄中，要設定 _config.yml 的 root (網站根目錄) 123# URLurl: https:&#x2F;&#x2F;teishashu.github.io&#x2F;root: &#x2F;blogger&#x2F; 重新上傳 1hexo d 需要等一下再刷新網頁","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://teishashu.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://teishashu.github.io/tags/Hexo/"}]},{"title":"Hexo 建立部落格(1) - 常用指令","slug":"hexo-code","date":"2020-06-24T16:00:00.000Z","updated":"2020-07-16T04:24:45.211Z","comments":true,"path":"2020/06/25/hexo-code/","link":"","permalink":"https://teishashu.github.io/2020/06/25/hexo-code/","excerpt":"生成靜態網頁(全寫hexo generater)會產生public檔案 1hexo g","text":"生成靜態網頁(全寫hexo generater)會產生public檔案 1hexo g 本地端預覽(全寫hexo serve) 1hexo s 上傳遠端deploy 文件生成後立即部屬上去遠端網站(可以省略 hexo g) 1hexo d watch 監視文件變動 (-w)網站存檔時自動升成新的靜態網頁(適合測試網站時使用) 12&#x2F;&#x2F; 例子hexo g -w clean 清除清除暫存(db.json)和已生成的靜態文件(public) 1hexo clean 更換主題時生成有問題可以使用 錯誤訊息紀錄會生成一個 debug.log 檔案裡面 1hexo --debug 新增文章草稿文章雖然一開始比較想要用手動，但是指令比較快還是需要熟悉，而且會自動把每頁需要的…建立好。 (手動)在 source 的資料夾建立 _drafts 資料夾，新增一份.md。 (指令)新增草稿文章 1hexo new draft &lt;文章標題&gt; 發布草稿文章 1hexo publish draft &lt;文章標題&gt; 其他頁面除了首頁，像關於我們等其他頁面。 (手動)在 source 資料夾下面新增想要的資料夾名稱，裡面放index.md (指令) 1hexo new page &lt;頁面名稱&gt; 也會產生手動的效果.在改檔案裡面的內容就可以 (範例):tags 標籤、categories 分類的頁面a. 新增 1hexo new page tags b. 增加頁面 type 屬性在 source/tags 資料夾中的 index.md頁面增加 type 屬性，就可以自動有相關的效果。 123---type: &quot;tags&quot;--- categories 分類頁面也是一樣的作法，type: &quot;categories&quot; 就可以 文章折疊預覽參考文章: 让hexo的首页只显示文章的部分内容而不是全部 | 朱启的个人博客我是用裡面的第二項.在頁面中增加&lt;!--more--&gt;沒想到只是這樣註記就有這效果!!","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://teishashu.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://teishashu.github.io/tags/Hexo/"}]}],"categories":[{"name":"Vue","slug":"Vue","permalink":"https://teishashu.github.io/categories/Vue/"},{"name":"Javascript","slug":"Javascript","permalink":"https://teishashu.github.io/categories/Javascript/"},{"name":"AJAX","slug":"AJAX","permalink":"https://teishashu.github.io/categories/AJAX/"},{"name":"CSS","slug":"CSS","permalink":"https://teishashu.github.io/categories/CSS/"},{"name":"Gsap","slug":"Gsap","permalink":"https://teishashu.github.io/categories/Gsap/"},{"name":"Hexo","slug":"Hexo","permalink":"https://teishashu.github.io/categories/Hexo/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://teishashu.github.io/tags/Vue/"},{"name":"VueX","slug":"VueX","permalink":"https://teishashu.github.io/tags/VueX/"},{"name":"Nuxt","slug":"Nuxt","permalink":"https://teishashu.github.io/tags/Nuxt/"},{"name":"RESTful API","slug":"RESTful-API","permalink":"https://teishashu.github.io/tags/RESTful-API/"},{"name":"Javascript","slug":"Javascript","permalink":"https://teishashu.github.io/tags/Javascript/"},{"name":"AJAX","slug":"AJAX","permalink":"https://teishashu.github.io/tags/AJAX/"},{"name":"CSS","slug":"CSS","permalink":"https://teishashu.github.io/tags/CSS/"},{"name":"網頁特效","slug":"網頁特效","permalink":"https://teishashu.github.io/tags/%E7%B6%B2%E9%A0%81%E7%89%B9%E6%95%88/"},{"name":"Gsap","slug":"Gsap","permalink":"https://teishashu.github.io/tags/Gsap/"},{"name":"source maps","slug":"source-maps","permalink":"https://teishashu.github.io/tags/source-maps/"},{"name":"Hexo","slug":"Hexo","permalink":"https://teishashu.github.io/tags/Hexo/"}]}